<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN" "http://www.w3.org/TR/REC-html40/frameset.dtd"> 
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-2022-jp">
<link rel="stylesheet" type="text/css" href="README.css">
<link rel="prev" href="MANUAL.html">
<link rel="next" href="CONTENTS.html">
<title>mayu - MANUAL - CUSTOMIZE</title>
</head>

<body class="manual">

<div class="main">
<dl>
  <dt class="h1"><a name="CUSTOMIZE" href="MANUAL.html#CUSTOMIZE">4. customize</a>
      
  <dd class="d1">
      <div>
      <p>付属の <code>.mayu</code> (<a href="dot.mayu"><code>dot.mayu</code></a>) を利用すれば、エディットコントロールで Emacs 風の操作ができるようになりますが、<code>.mayu</code> をカスタマイズすることによって、Windows を自分の好きなキーバインディングで利用することができるようになります。</p>
      
      <p><code>.mayu</code> は<a href="#HOME">ホームディレクトリ</a>から検索されます。</p>

      <p><code>.mayu</code> は上から下へ読まれていき、重複する記述があれば、より下に書かれているものが有効になります。コメントは <code>#</code> ではじめます。アルファベットの大文字と小文字は区別されません。詳しい文法は <a href="syntax.txt"><code>syntax.txt</code></a> を参照してください。</p>

      <p>この章を読む前に、<a href="contrib/mayu-settings.txt"><code>contrib/mayu-settings.txt</code></a> を読んで付属の設定ファイルについて理解を深めておくことをお勧めします。</p>
      
      <dl>
	<dt class="h2"><a name="key">i. キー割り当ての変更</a>
	    
	<dd class="d2">
	    <div>
	    <p>キー割り当てを変更するには、以下のように記述をします。</p>
	    
	    <p class="sample">
	    key <em>KEY</em> =&gt; <em>KEY</em> や <em>FUNCTION</em> …
	    </p>
	    
	    <p><code>=&gt;</code> より左の <code><em>KEY</em></code> をキーボードで押すと、Windows へは <code>=&gt;</code> より右の <code><em>KEY</em></code> が順番に入力されます。また、右に <code><em>FUNCTION</em></code> が書かれている場合はウィンドウの最大化や移動などの機能が実行されます。</p>
	    
	    <p><code><em>KEY</em></code> は<a href="#keyboard">キーボード定義</a>で定義されるもので、デフォルトでは <a href="109.mayu"><code>109.mayu</code></a> 又は <a href="104.mayu"><code>104.mayu</code></a> で定義されている <code><em>KEY</em></code> が使用できます。</p>
	    
	    <dl>
	      <dt class="h3"><a name="modifier">モディファイヤの指定</a>
	      <dd class="d3">
		  <div>
		  <p><code><em>KEY</em></code> の前に以下のような記号を付けることによって、コントロールキーなどの状態を表現できます。また、これらをモディファイヤと呼ぶことにします。</p>

		  <ul>
		    <li><code>C-</code> は、<kbd>[Control]</kbd> が押されていることを表します
		    <li><code>M-</code> か <code>A-</code> は、<kbd>[Alt]</kbd> が押されていることを表します
		    <li><code>S-</code> は、<kbd>[Shift]</kbd> が押されていることを表します
		    <li><code>NL-</code> は、<kbd>[NumLock]</kbd> がロック状態であることを表します
		    <li><code>CL-</code> は、<kbd>[CapsLock]</kbd> がロック状態であることを表します
		    <li><code>SL-</code> は、<kbd>[ScrollLock]</kbd> がロック状態であることを表します
		    <li><code>IL-</code> は、IME が on になっていることを表します
		    <li><code>IC-</code> は、IME で変換中であることを表します
		  </ul>
		  
		  <p>以下のように記述すると、<kbd>[Control]</kbd> + <kbd>[A]</kbd> を押した時に、Windows へは <kbd>[HOME]</kbd> キーが入力されます。</p>
		  
		  <p class="sample">
		  key C-A =&gt; HOME
		  </p>
		  </div>

	      <dt class="h3"><a name="ignoreModifier">モディファイヤキーの無視</a>
	      <dd class="d3">
		  <div>
		  <p>上記の例では左側に <code>C-A</code> と記述していますが、この記述では、ロックキーなどは押されていても押されてなくても良いと記述していることになります。たとえば、<kbd>[CapsLock]</kbd> を押したあとで <kbd>[Control]</kbd> + <kbd>[A]</kbd> を押しても、押さずに <kbd>[Control]</kbd> + <kbd>[A]</kbd> を押しても、Windows へは <kbd>[Home]</kbd> が入力されます。</p>
		  
		  <p>特定のモディファイヤの状態を無視したい場合は、モディファイヤに "<code>*</code>" をつけます。逆にモディファイヤが必ず押されていなければならない場合は付けません。またモディファイヤが必ず離されていなければならない場合は "<code>~</code>" を付けます。たとえば、</p>
		  
		  <p class="sample">
		  key *S-F9 =&gt; &amp;WindowMinimize
		  </p>
		  
		  <p class="continue">このように記述すると、<kbd>[F9]</kbd> 又は <kbd>[Shift]</kbd> + <kbd>[F9]</kbd> でウィンドウを最小化することができますが、例えば、<kbd>[Control]</kbd> + <kbd>[F9]</kbd> ではできません。</p>
		  
		  <p>デフォルトでは、暗黙に <code>~C-~M-~S-*NL-*CL-*SL-*IL-~IC-</code> が指定されていることになっていますが、<a href="#defaultModifier">変更</a>できます。</p>
		  
		  <p>また、<kbd>[Shift]</kbd> は必ず押されていてほしいがほかのモディファイヤはどうでもいいという場合は、</p>
		  
		  <p class="sample">
		  key S-*F9 =&gt; &amp;WindowMinimize
		  </p>

		  <p class="continue">というように "<code>*</code>" をキーの直前に記述します。"<code>~</code>" についても同様です。</p>
		  </div>

	      <dt class="h3"><a name="inputModifier">入力されたキーと同じモディファイヤの指定</a>
	      <dd class="d3">
		  <div>
		  <p><code>=&gt;</code> より右側でのモディファイヤの指定の方法です。</p>

		  <p class="sample">
		  key *S-A =&gt; C-*S-B
		  </p>
		  
		  <p>例えばこのように記述した場合、<kbd>[Shift]</kbd> + <kbd>[A]</kbd> を押すと、Windows へは <kbd>[Shift]</kbd> + <kbd>[Control]</kbd> + <kbd>[B]</kbd> が入力されます。<kbd>[A]</kbd> を押すと、Windows へは <kbd>[Control]</kbd> + <kbd>[B]</kbd> が入力されます。</p>
		  
		  <p>つまり、<code>=&gt;</code> の右側で <code>*</code> で指定されたモディファイヤは、キーボードで実際に入力したモディファイヤと同じになるように設定されます。</p>
		  
		  <p>したがって、<kbd>[A]</kbd> を <kbd>[B]</kbd> と入れ替えたい場合は、</p>
		  
		  <p class="sample">
		  key *A =&gt; *B<br>
		  key *B =&gt; *A
		  </p>

		  <p class="continue">となります。</p>
		  </div>

	      <dt class="h3"><a name="keyUpDown">キーを押す/離す</a>
	      <dd class="d3">
		  <div>
		  <p><code><em>KEY</em></code> の前にモディファイヤと同じように <code>D-</code> と <code>U-</code> を付けることができます。これは、それぞれキーの押すことと離すことに対応しています。デフォルトでは <code>*D-*U-</code> が指定されています。例えば、</p>
		  
		  <p class="sample">
		  key A =&gt; B C
		  </p>
		  
		  <p class="continue">という記述は、</p>
		  
		  <p class="sample">
		  key *U-*D-A =&gt; D-B U-B D-C U-C
		  </p>

		  <p class="continue">と同じであり、さらに次のものとも同じになります。キーリピートが起こった場合は、<code>~U-D-A</code> が何度も実行され、キーを離したときに <code>U-~D-A</code> が実行されます。</p>
		  
		  <p class="sample">
		  key ~U-D-A =&gt; D-B U-B D-C<br>
		  key U-~D-A =&gt; U-C
		  </p>
		  </div>

	      <dt class="h3"><a name="defaultModifier">デフォルトモディファイヤの変更</a>
	      <dd class="d3">
		  <div>
		  <p>デフォルトでは、左側のキーには <code>~C-~M-~S-*NL-*CL-*SL-*IL-~IC-</code> が指定されていますが、これを変更することができます。例えば、</p>
		  
		  <p class="sample">
		  key IC-* =
		  </p>

		  <p class="continue">と記述すると、この文以降のデフォルトモディファイヤは <code>~C-~M-~S-*NL-*CL-*SL-*IL-*IC-</code> となります。</p>
		  </div>
	    </dl>
	    </div>

	<dt class="h2"><a name="keymap">ii. キーマップ定義</a>

	<dd class="d2">
	    <div>
	    <p>「窓使いの憂鬱」には、キーマップという概念があります。キーマップにカスタマイズしたいキー情報を書き込んでゆき、ウィンドウごとにキーマップを使い分けます。キーマップを定義するには、以下のどれかの文を書いてからキーを設定します。</p>
	    
	    <p class="sample">
	    keymap <em>キーマップ名</em><br>
	    keymap2 <em>キーマップ名</em><br>
	    window <em>キーマップ名</em> <em>ウィンドウクラス名</em><br>
	    window <em>キーマップ名</em> ( <em>ウィンドウクラス名</em> &amp;&amp; <em>ウィンドウタイトル名</em> )<br>
	    window <em>キーマップ名</em> ( <em>ウィンドウクラス名</em> || <em>ウィンドウタイトル名</em> )<br>
	    </p>
	    
	    <p>例えば、メモ帳で <kbd>[Control]</kbd> + <kbd>[Z]</kbd> を押すと最小化されるが、メモ帳以外のエディットコントロールで <kbd>[Control]</kbd> + <kbd>[Z]</kbd> を押すと単なる <kbd>[Z]</kbd> キーと同じになるという指定がしたい場合は、</p>
	    
	    <p class="sample">
	    window EditControl /:Edit$/ : Global<br>
	    key C-Z =&gt; Z<br>
	    window Notpad /Notepad:Edit$/ : Global<br>
	    key C-Z =&gt; &amp;WindowMinimize
	    </p>
	    
	    <p class="continue">と記述します。ここで <code>/Notepad:Edit$/</code> はメモ帳の上にあるエディットコントロールの<code><em>ウィンドウクラス名</em></code>を表しています。<code><em>ウィンドウクラス名</em></code>は正規表現で記述します。<code>: Global</code> は<code><em>親キーマップ</em></code>を指定しています。</p>
	    
	    <dl>
	      <dt class="h3"><a name="windowClass">ウィンドウクラス/タイトル名</a>
		  
	      <dd class="d3">
		  <div>
		  <p>Windows の全てのウィンドウは、何らかのウィンドウクラスに属しています。例えば、メモ帳のウィンドウクラス名は <code>Notepad</code> で、エディットコントロールのウィンドウクラス名は <code>Edit</code> です。</p>
		  
		  <p>「窓使いの憂鬱」は、どのウィンドウでどのキーを押したらどんな動作をするか、ということを区別するために<code><em>ウィンドウクラス名</em></code>と<code><em>ウィンドウタイトル名</em></code>を用いています。そのために、「窓使いの憂鬱」ではウィンドウの重なりの状態を "<code>:</code>" で繋げて表現します。例えば、メモ帳の上のエディットコントロールの<code><em>ウィンドウクラス名</em></code>ならば、</p>

		  <p class="sample">
		  C:\winnt\system32\notepad.exe:Notepad:Edit
		  </p>
		  
		  <p class="continue">と表現します。ただし、<code><em>ウィンドウクラス名</em></code>の一番最初にはそのアプリケーションのパス名を付けています。</p>
		  
		  <p><code>window</code> 文には、この<code><em>ウィンドウクラス名</em></code>と<code><em>ウィンドウタイトル名</em></code>を記述することができますが、<code><em>ウィンドウクラス名</em></code>全てを書く必要はなく、正規表現で省略することができます。</p>
		  
		  <p>例えば、<code>/:Edit$/</code> は全てのエディットコントロールの<code><em>ウィンドウクラス名</em></code>を表しますし、<code>/:#32770.*:Edit$/</code> ならば、ダイアログボックス上にある全てのエディットコントロールの<code><em>ウィンドウクラス名</em></code>を表します (<code>#32770</code> はダイアログボックスのウィンドウクラス名)。</p>
		  
		  <p>個々のウィンドウの<code><em>ウィンドウクラス名</em></code>と<code><em>ウィンドウタイトル名</em></code>を調べるには、後述の <a href="MANUAL.html#CLASSNAME">window class investigation</a> を参照してください。</p>
		  
		  <p><code><em>ウィンドウクラス名</em></code>と<code><em>ウィンドウタイトル名</em></code>の両方を記述する場合は、括弧で囲みその間を <code>&amp;&amp;</code> か <code>||</code> で区切ります。<code>&amp;&amp;</code> の場合は、両方にマッチするようなウィンドウを表し、<code>||</code> の場合はどちらか一方にマッチするようなウィンドウを表します。</p>
		  </div>

	      <dt class="h3"><a name="regexp">正規表現について</a>
		  
	      <dd class="d3">
		  <div>
		  <p><code><em>ウィンドウクラス名</em></code>と<code><em>ウィンドウタイトル名</em></code>には正規表現が使用できます。正規表現は <code>/.../</code> で囲むか、<code>\m@...@</code>で囲みます (ただし<code>@</code>はどんな文字でもよし)。</p>
		  <ul>
		    <li>"<code>|</code>" Alternation
		    <li>"<code>*</code>" Match 0 or more times
		    <li>"<code>+</code>" Match 1 or more times
		    <li>"<code>?</code>" Match 1 or 0 times
		    <li>"<code>.</code>" Match any character
		    <li>"<code>^</code>" Match the beginning of the string
		    <li>"<code>$</code>" Match the end of the string
		    <li>"<code>\b</code>" Match a word boundary
		    <li>"<code>\B</code>" Match a non word boundary
		    <li>"<code>\w</code>" Match a word character (<code>[0-9a-z_]</code>)
		    <li>"<code>\W</code>" Match a non word character
		    <li>"<code>\s</code>" Match a whitespace character
		    <li>"<code>\S</code>" Match a non-whitespace character
		    <li>"<code>\d</code>" Match a digit character
		    <li>"<code>\D</code>" Match a non-digit character
		    <li>"<code>(</code>" "<code>)</code>" Grouping
		    <li>"<code>[</code>" "<code>]</code>" Character class
		  </ul>
		  </div>

	      <dt class="h3"><a name="parentKeymap">親キーマップ</a>
		  
	      <dd class="d3">
		  <div>
		  <p>親キーマップとは、現在のキーマップに適切なキー割り当てが定義されていない場合に、キーを捜しに行くキーマップです。"<code>:</code>" の後ろに<em>親キーマップ名</em>を書きます。例えば、</p>
		  
		  <p class="sample">
		  keymap sub : Global<br>
		  key	C-A =&gt; &amp;WindowMinimize<br>
		  window EditControl /:Edit$/ : sub<br>
		  key	C-A =&gt; &amp;KeymapParent
		  </p>
		  
		  <p class="continue">と記述した場合、エディットコントロールで <kbd>[Control]</kbd> + <kbd>[A]</kbd> を入力すると、ウィンドウは最小化されます。つまり、<a href="#function_KeymapParent"><code>&amp;KeymapParent</code></a> を記述することで親キーマップで定義されたキーを利用することができるのです。もし、<em>親キーマップ名</em>が指定されていなければ <a href="#function_Default"><code>&amp;Default</code></a> 扱いとなり、ウィンドウへキーがそのまま入力されます。</p>
		  </div>

	      <dt class="h3"><a name="defaultKey">デフォルトキー</a>
		  
	      <dd class="d3">
		  <div>
		  <p><code>keymap</code>、<code>window</code>、<code>keymap2</code> には、最後にキーを羅列することによってデフォルトキーを定義することができます。例えば、</p>
		  
		  <p class="sample">
		  window EditControl /:Edit$/ : Global =&gt; A<br>
		  key *B =&gt; *C
		  </p>
		  
		  <p class="continue">と記述すると、<kbd>[B]</kbd> を入力すると <kbd>[C]</kbd> を入力したことになるが、<kbd>[B]</kbd> 以外のキーを入力すると、<kbd>[A]</kbd> を入力したことになります。また、デフォルトキーを指定しなかった場合のデフォルトキーは、<code>keymap</code> と <code>window</code> の場合は <a href="#function_KeymapParent"><code>&amp;KeymapParent</code></a> で、<code>keymap2</code> の場合は <a href="#function_Undefined"><code>&amp;Undefined</code></a> になります。</p>
		  </div>

	      <dt class="h3"><a name="keymap2">二段階キーマップ</a>
		  
	      <dd class="d3">
		  <div>
		  <p><code>keymap2</code> はデフォルトキーが <a href="#function_Undefined"><code>&amp;Undefined</code></a> になってるようなキーマップで、主に <a href="#function_Prefix"><code>&amp;Prefix</code></a> を利用して 2 ストロークキーを記述する時に使用します。</p>
		  </div>

	      <dt class="h3"><a name="initialKeymap">初期キーマップ</a>
		  
	      <dd class="d3">
		  <div>
		  <p><code>.mayu</code> の一番最初の行には、</p>
		  
		  <p class="sample">
		  window Global ( // || // ) =&gt; &amp;OtherWindowClass
		  </p>
		  
		  <p class="continue">という行が隠れていると考えて下さい。つまり、<code>.mayu</code> で何もキーマップを指定せずに書き始めると、<em>キーマップ名</em> <code>Global</code> のキーマップに対するキー定義になるということです。そして、<code>Global</code> キーマップのデフォルトキーは <a href="#function_OtherWindowClass"><code>&amp;OtherWindowClass</code></a> が設定されています。</p>
		  </div>

	      <dt class="h3"><a name="conflictKeymap">矛盾したキーマップの指定</a>
		  
	      <dd class="d3">
		  <div>
		  <p>同じキーマップに対する <code>keymap</code> や <code>window</code> や <code>keymap2</code> は何度でも指定できますが、矛盾する指定をしてはいけません。例えば、</p>
		  
		  <p class="sample">
		  keymap Amap : Global<br>
		  ...<br>
		  keymap Bmap : Amap<br>
		  ...<br>
		  keymap Amap : Global<br>
		  ...
		  </p>
		  
		  という指定は問題ありませんが、
		  
		  <p class="sample">
		  keymap Amap : Global<br>
		  ...<br>
		  keymap Bmap : Amap<br>
		  ...<br>
		  keymap Amap : Bmap	# 矛盾<br>
		  ...
		  </p>
		  
		  <p class="continue">という指定はしてはいけません。この場合、<code>keymap Amap : Bmap</code> のかわりに <code>keymap Amap : Global</code> が指定されたものとみなされます。エラーは出ません。</p>
		  </div>

	      <dt class="h3"><a name="matchManyClasses"><code>window</code> に複数該当する場合</a>
		  
	      <dd class="d3">
		  <div>
		  <p>例えば、</p>
		  
		  <p class="sample">
		  window EditControl /:Edit$/ : Global<br>
		  key A = A space E D I T enter<br>
		  key B = B space E D I T enter<br>
		  window Notepad /:Notepad/ : Global<br>
		  key A = A space N O T E P A D enter<br>
		  key C = C space N O T E P A D enter
		  </p>
		  
		  <p class="continue">という記述をしたとします。ここで、「メモ帳」を立ち上げると、メモ帳の<code><em>ウィンドウクラス名</em></code>は</p>
		  
		  <p class="sample">
		  C:\winnt\system32\notepad.exe:Notepad:Edit
		  </p>
		  
		  <p class="continue">となっているので、<code>/:Edit$/</code> と <code>/:Notepad/</code> は両方共もメモ帳の<code><em>ウィンドウクラス名</em></code>に該当します。この時、<kbd>[A]</kbd> を入力すると、メモ帳には「<code>a notepad</code>」と表示されます。これは、重複する記述があれば、より下に書かれているものが有効になるからです。しかし、<kbd>[B]</kbd> を入力した場合は、重複していないので、メモ帳には「<code>b edit</code>」と表示されることになります。</p>
		  
		  <p><kbd>[B]</kbd> を入力した場合に、内部で行われる処理は以下のようになります。</p>
		  
		  <ol>
		    <li>まず<code><em>ウィンドウクラス名</em></code>は <code>/:Notepad/</code> に該当しますが、キー割り当てがないので、<code>window</code> のデフォルトキーである <code>&amp;KeymapParent</code> が採用されます。
		    <li><code>&amp;KeymapParent</code> は<em>親キーマップ</em>の参照なので、<code>Global</code> キーマップを参照します。
		    <li>そうすると、<code>Global</code> キーマップでも <kbd>[B]</kbd> の割り当てがないので、<code>Global</code> キーマップのデフォルトキーである、<code>&amp;OtherWindowClass</code> が採用されます。
		    <li><code>&amp;OtherWindowClass</code> が採用されると、まず、他に該当する<code><em>ウィンドウクラス名</em></code>がないかどうか探します。もしなければ、<code>&amp;Default</code> 扱いとなります。この場合は <code>/:Edit$/</code> に該当します。
		    <li><code>/:Edit$/</code> に該当したので、<code>/:Edit$/</code> の <kbd>[B]</kbd> が採用されます。したがって、「b edit」と表示されることとなります。
		  </ol>
		  </div>
	    </dl>
	    </div>

	<dt class="h2"><a name="mod">iii. モディファイヤキー割り当ての変更</a>

	<dd class="d2">
	    <div>
	    <p class="sample">
	    mod <em>モディファイヤキー名</em> = <em>キー名</em> …<br>
	    mod <em>モディファイヤキー名</em> += <em>キー名</em> …<br>
	    mod <em>モディファイヤキー名</em> -= <em>キー名</em> …<br>
	    </p>

	    <p>最初の 3 つは、<em>キー名</em>で指定したキーをモディファイヤキーにしたり (<code>=</code>) 追加したり (<code>+=</code>) 削除したり (<code>-=</code>) します。各キーマップ毎に割り当てます。明示的に割り当てない場合は、親キーマップから引き継がれます。例えば、</p>

	    <p class="sample">
	    mod shift += 無変換
	    </p>

	    <p class="continue">は、<kbd>[無変換]</kbd> キーを shift モディファイヤキーにします。従って、</p>

	    <p class="sample">
	    key S-A =&gt; X
	    </p>
	    
	    <p class="continue">という記述があった場合に、<kbd>[無変換]</kbd> + <kbd>[A]</kbd> を押すと <kbd>[X]</kbd> を入力したことになります。正確には、<kbd>[無変換押す]</kbd> <kbd>[X押す]</kbd> <kbd>[X離す]</kbd> <kbd>[無変換離す]</kbd> というキーが Windows へ入力されます。これでは都合が悪いということは多いと思われるので、</p>

	    <p class="sample">
	    key *無変換 =&gt; *LShift
	    </p>
	    
	    <p class="continue">として <kbd>[無変換]</kbd> キーを押すと <kbd>[LShift]</kbd> が入力されるように割り当てます。そうすれば、Windows へは <kbd>[LShift押す]</kbd> <kbd>[LShift離す]</kbd> <kbd>[X押す]</kbd> <kbd>[X離す]</kbd> というキーが入力されます。</p>
	    
	    <p><em>モディファイヤキー名</em>には、<code>shift</code>, <code>alt</code> (<code>meta</code>, <code>menu</code>), <code>control</code> (<code>ctrl</code>), <code>windows</code> (<code>win</code>), <code>mod0</code>〜<code>mod9</code> が記述できます。括弧の中の名前も使用できます。</p>
	    
	    <p><code>mod0</code>〜<code>mod9</code> は「窓使いの憂鬱」の中でのみ有効なモディファイヤで、例えば以下のように使用します。</p>
	    
	    <p class="sample">
	    mod mod0 = ↑<br>
	    key M0-← =&gt; ← ↑
	    </p>

	    <p class="continue">このように割り当てると、<kbd>[↑]</kbd> を押しながら <kbd>[←]</kbd> を押すとカーソルが左斜め上へ移動することになります。</p>

	    <dl>
	      <dt class="h3"><a name="trueModifier">真のモディファイヤ</a>
		  
	      <dd class="d3">
		  <div>
		  <p>モディファイヤにしたいキーの前に "<code>!</code>" を付けると、<em>真のモディファイヤ</em>になります。例えば、</p>
		  
		  <p class="sample">
		  mod shift += !無変換<br>
		  key 無変換 =&gt; Y<br>
		  key S-A =&gt; X
		  </p>
		  
		  <p class="continue">と記述した場合、<kbd>[無変換]</kbd> + <kbd>[A]</kbd> を押すと <kbd>[X押す]</kbd> <kbd>[X離す]</kbd> というキーが Windows へ入力されます。Windows からは、<kbd>[無変換]</kbd> キーが押されたということは分かりませんし、<kbd>[Y]</kbd> も Windows へ入力されることはありません。つまり、真のモディファイヤに定義されているキーや <code><em>FUNCTION</em></code> などは実行されません。</p>
		  
		  <p>以下のような行を記述すると、</p>
		  
		  <p class="sample">
		  mod !<em>モディファイヤキー名</em>
		  </p>

		  <p class="continue">その<em>モディファイヤキー名</em>に割り当てられているモディファイヤを全て<em>真のモディファイヤ</em>に変更します。</p>
		  </div>

	      <dt class="h3"><a name="oneShotModifier">One Shot モディファイヤ</a>
		  
	      <dd class="d3">
		  <div>
		  <p>モディファイヤにしたいキーの前に "<code>!!</code>" を付けると、<em>One Shot モディファイヤ</em>になります。たとえば、</p>
		  
		  <p class="sample">
		  mod shift = !!LShift<br>
		  key S-A =&gt; X<br>
		  key LShift =&gt; Y
		  </p>
		  
		  <p class="continue">と記述した場合、<kbd>[LShift]</kbd> を押してすぐ離した場合は、Windows へは、<kbd>[Y]</kbd> が入力されますが、<kbd>[LShift]</kbd> + <kbd>[A]</kbd> を入力した場合は、<kbd>[X]</kbd> のみが Windows へ入力されます。</p>
		  
		  <p>以下のような行を記述すると、</p>
		  
		  <p class="sample">
		  mod !!<em>モディファイヤキー名</em>
		  </p>

		  <p class="continue">その<em>モディファイヤキー名</em>に割り当てられているモディファイヤを全て<em>One Shot モディファイヤ</em>に変更します。</p>
		  </div>

	      <dt class="h3"><a name="lock">ロックキー</a>
		  
	      <dd class="d3">
		  <div>
		  <p>「窓使いの憂鬱」には、「窓使いの憂鬱」の中でのみ有効なロックキーが存在します。これらはキーのモディファイヤとして <code>L0-</code>〜<code>L9-</code> を書くことができ、<a href="#function_Toggle"><code>&amp;Toggle</code></a> を使うことによりトグルさせることができます。例えば、
		  
		  <p class="sample">
		  key ひらがな =&gt; &amp;Toggle(Lock0)<br>
		  key L0-A =&gt; B
		  </p>

		  <p class="continue">と記述すると、<kbd>[ひらがな]</kbd> キーがトグル状態になっているときに <kbd>[A]</kbd> を押すと Windows へは <kbd>[B]</kbd> が入力されます。</p>
		  </div>
	    </dl>
	    </div>

	<dt class="h2"><a name="keyseq" class="a2">iv. キーシーケンス定義</a>

	<dd class="d2">
	    <div>
	    <p class="sample">
	    keyseq $<em>キーシーケンス名</em> = <em>KEY</em> や <em>FUNCTION</em> …
	    </p>
	    
	    <p><code>keyseq</code> を使うことで、一連のキー入力に対して名前を付けることができます。例えば、</p>
	    
	    <p class="sample">
	    keyseq $Right2Times = Right Right<br>
	    key C-F =&gt; $Right2Times
	    </p>
	    
	    <p class="continue">とすると、<kbd>[Control]</kbd> + <kbd>[F]</kbd> で右に二つカーソルを進めることができます。又、</p>
	    
	    <p class="sample">
	    key C-F =&gt; Right Right
	    </p>
	    
	    <p class="continue">は、<code>$Right2Times</code> という名前が定義されないこと以外は、先の例と同じになります。</p>
	    </div>

	<dt class="h2"><a name="event" class="a2">v. イベント定義</a>
	    
	<dd class="d2">
	    <div>
	    <p class="sample">
	    event <em>EVENT</em> = <em>KEY</em> や <em>FUNCTION</em> …
	    </p>
	    
	    <p>あるイベントが起こったときに <code><em>KEY</em></code> や <code><em>FUNCTION</em></code> を実行します。イベントはキーマップ毎に定義され、親キーマップにイベントが定義されていてもそれは無視されます。</p>
	    
	    <p><code><em>EVENT</em></code> には以下のものが指定できます。</p>

	    <ul>
	      <li><code>prefixed</code>: <a href="#function_Prefix"><code>&amp;Prefix</code></a> によってキーマップが指定された時。
	      <li><code>before-key-down</code>: キーが押さた時。
	      <li><code>after-key-up</code>: キーが離された後。
	    </ul>
	    </div>

	<dt class="h2"><a name="keyboard">vi. キーボード定義</a>
	    
	<dd class="d2">
	    <div>
	    <p>デフォルトのキーボード定義は <a href="109.mayu"><code>109.mayu</code></a> 又は <a href="104.mayu"><code>104.mayu</code></a> に書かれています。</p>

	    <dl>
	      <dt class="h3"><a name="def_key">キー定義</a>

	      <dd class="d3">
		  <div>
		  <p>キーボードの物理的なキーを定義します。</p>
		  
		  <p class="sample">
		  def key <em>キー名</em>… = <em>スキャンコード</em>…
		  </p>
		  
		  <p>キーが発生する<code><em>スキャンコード</em></code>を記述していきます。<code><em>スキャンコード</em></code>は数字で書き、<code>E0-</code> や <code>E1-</code> という拡張キーフラグをつけることができます。又、</p>

		  <p class="sample">
		  def key Pause = E1-0x1d 0x45
		  </p>
		  
		  <p>このように一連の<em>スキャンコード</em>を発生させるキーにはスキャンコードを書き並べます。</p>
		  </div>

	      <dt class="h3"><a name="def_mod">モディファイヤ定義</a>

	      <dd class="d3">
		  <div>
		  <p>キーボードの物理的なモディファイヤキーを定義します。</p>
		  
		  <p class="sample">
		  def mod <em>モディファイヤ名</em> = <em>キー名</em>…
		  </p>

		  <p><code><em>モディファイヤ名</em></code>には、<code>shift</code>, <code>alt</code> (<code>meta</code>, <code>menu</code>), <code>control</code> (<code>ctrl</code>), <code>windows</code> (<code>win</code>) が記述できます。括弧の中の名前も使用できます。</p>
		  </div>

	      <dt class="h3"><a name="def_sync">同期定義</a>
		  
	      <dd class="d3">
		  <div>
		  <p><code>&amp;Sync</code> に使用する<code><em>スキャンコード</em></code>を定義します。</p>
		  
		  <p class="sample">
		  def sync = <em>スキャンコード</em>…
		  </p>
		  
		  <p><code>&amp;Sync</code> が実行されるとき、「窓使いの憂鬱」はこの<code><em>スキャンコード</em></code>を Windows に送ります。そして、各ウィンドウがこのキーが入力されたことを「窓使いの憂鬱」へ連絡してくるまで処理を中断します。このようにして同期をとるので、この<code><em>スキャンコード</em></code>が不正に設定されていると、同期がとれず「窓使いの憂鬱」が 5 秒ほど固まります (つまり 5 秒ほど何も入力できなくなります)。</p>
		  </div>

	      <dt class="h3"><a name="def_alias">別名定義</a>
		  
	      <dd class="d3">
		  <div>
		  <p>キーの別名を定義します。</p>
		  
		  <p class="sample">
		  def alias <em>別名</em> = <em>キー名</em>
		  </p>

		  <p>別名が既存のキー名と同じだった場合は、別名のほうが優先されます。</p>
		  </div>
	    </dl>
	    </div>

	<dt class="h2"><a name="include">vii. ファイル読み込み</a>

	<dd class="d2">
	    <div>
	    <p class="sample">
	    include <em>ファイル名</em>
	    </p>
	    
	    <p>と書くことによって、その行に<em>ファイル名</em>で示されるファイルを挿入することができます。<em>ファイル名</em>は<a href="#HOME">ホームディレクトリ</a>から検索されます。</p>
	    
	    <dl>
	      <dt class="h3"><a name="HOME">ホームディレクトリ</a>
	      <dd class="d3">
		  <div>
		  <p>ホームディレクトリは、</p>

		  <ul>
		    <li>設定(S)... で指定したファイルのあるディレクトリ
		    <li><code>%HOME%</code>
		    <li><code>%HOMEDRIVE%%HOMEPATH%</code>
		    <li><code>%USERPROFILE%</code>
		    <li><code>mayu.exe</code> のある場所
		  </ul>
		  
		  <p class="continue">のどれかになります。上から順番に検索されます。</p>
		  </div>
	    </dl>
	    </div>

	<dt class="h2"><a name="cond">viii. 条件分岐</a>

	<dd class="d2">
	    <div>
	    <p>シンボルを定義して、そのシンボルによって条件分岐させることができます。</p>
	    
	    <p class="sample">
	    define <em>シンボル</em><br>
	    if ( <em>シンボル</em> )<br>
	    〜<br>
	    else<br>
	    〜<br>
	    endif
	    </p>

	    例えば次のように記述すると、
	    
	    <p class="sample">
	    if ( SwapAB )<br>
	    key *A =&gt; *B<br>
	    key *B =&gt; *A<br>
	    endif
	    </p>

	    <p class="continue"><code>SwapAB</code> というシンボルが <code>define</code> されている場合に、<kbd>[A]</kbd> と <kbd>[B]</kbd> を入れ替えます。</p>
	    
	    <p>「窓使いの憂鬱の設定」ダイアログボックスで <code>-Dシンボル名</code> を書くことでシンボルを定義することができます。</p>
	    </div>

	<dt class="h2"><a name="function">ix. <code><em>FUNCTION</em></code> リファレンス</a>

	<dd class="d2">
	    <div>
	    <dl class="function">
	      <dt class="h3"><a name="function_ClipboardCopy"><code>&amp;ClipboardCopy(<em>text</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p><em>text</em> をクリップボードへコピーします。</p>
		  </div>

	      <dt class="h3"><a name="function_ClipboardUpcaseDowncaseWord"><code>&amp;ClipboardUpcaseWord</code>, <code>&amp;ClipboardDowncaseWord</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>それぞれ、クリップボードの中身の文字を大文字化又は小文字化します。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_Default"><code>&amp;Default</code></a>

	      <dd class="d3">
		  <div>
		  <p>入力されたキーをそのまま Windows へ入力します。そのため、「窓使いの憂鬱」を起動してない時と同じ動作が期待できます。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_DescribeBindings"><code>&amp;DescribeBindings</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p><code>&amp;DescribeBindings</code> は、現在のキーマップでどのようなキー操作をするとどのような動作が起こるかを表示します。が、表示形式がいまいち分かりにくいのでどうしようか思案中。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_EditNextModifier"><code>&amp;EditNextModifier(<em>モディファイヤ</em>)</code></a>

	      <dd class="d3">
		  <div>
		  <p>次にユーザーがキーを入力した時に、<code><em>モディファイヤ</em></code> が押されていることにします。例えば、</p>
		  
		  <p class="sample">
		  key ESC =&gt; &amp;EditNextModifier(M-)
		  </p>
		  </div>
		  
		  <p class="continue">とすると、<kbd>[Alt]</kbd> + <kbd>[X]</kbd> などを <kbd>[ESCAPE][X]</kbd> などで代用することが可能になります。</p>
		  
	      <dt class="h3"><a name="function_EmacsEditKillLine"><code>&amp;EmacsEditKillLinePred</code>, <code>&amp;EmacsEditKillLineFunc</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>エディットコントロールで emacs の kill-line のような機能を実現します。使い方は <a href="emacsedit.mayu"><code>emacsedit.mayu</code></a> を参照のこと。</p>
		  </div>

	      <dt class="h3"><a name="function_HelpMessage"><code>&amp;HelpMessage(<em>title</em>, <em>message</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>IE5.0 が入っていれば、タスクトレイ付近にメッセージを表示します。<code><em>title</em></code> と <code><em>message</em></code> を省略すると、表示されているメッセージを消します。</p>
		  </div>

	      <dt class="h3"><a name="function_HelpVariable"><code>&amp;HelpVariable(<em>title</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>IE5.0 が入っていれば、タスクトレイ付近に <a href="#function_Variable"><code>&amp;Variable</code></a> で設定された値を表示します。</p>
		  </div>

	      <dt class="h3"><a name="function_Ignore"><code>&amp;Ignore</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>なにも起こりません。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_InvestigateCommand"><code>&amp;InvestigateCommand</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>ウィンドウへ送られてくる <code>WM_COMMAND</code> と <code>WM_SYSCOMMAND</code> を調べログに出力します。トグルになっていますので、調査が終わったらもう一度この <code><em>FUNCTION</em></code> を実行してください。さもないとアプリケーションの実行速度が遅くなる可能性があります。ログの出力は <a href="#function_PostMessage"><code>&amp;PostMessage</code></a> で使用することが出来ます。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_Keymap"><code>&amp;Keymap(<em>キーマップ名</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>別のキーマップのキーを指定します。例えば、</p>
		  
		  <p class="sample">
		  keymap sub : Global<br>
		  key	C-A =&gt; &amp;WindowMinimize<br>
		  window EditControl /:Edit$/ : Global<br>
		  key	C-A =&gt; &amp;Keymap(sub)
		  </p>
		  
		  <p class="continue">というように利用します。この場合、エディットコントロールで <kbd>[Control]</kbd> + <kbd>[A]</kbd> を入力すると、最小化されます。あまり実用的な機能はないかもしれません。ループしないように気をつけて利用してください。</p>
		  </div>

	      <dt class="h3"><a name="function_KeymapParent"><code>&amp;KeymapParent</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p><a href="#parentKeymap">親キーマップ</a>参照。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_KeymapWindow"><code>&amp;KeymapWindow</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>現在のウィンドウに定義されたキーマップのキーを入力します。プレフィックスキーの入力中に使用すると便利です。例えば</p>
		  
		  <p class="sample">
		  keymap2 NotepadC-X<br>
		  key	A =&gt; &amp;KeymapWindow<br>
		  window Notepad /:Notepad:Edit$/ : Global<br>
		  key	C-X =&gt; &amp;Prefix(NotepadC-X)<br>
		  key	A =&gt; T E S T
		  </p>
		  
		  <p class="continue">この場合、メモ帳で <kbd>[Control]</kbd> + <kbd>[X]</kbd> を押した後に <kbd>[A]</kbd> を入力すると、<code>&amp;KeymapWindow</code> は <code>Nodepad</code> キーマップに定義されているキーを入力しようとします。従って、<code>TEST</code> が入力されます。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_LoadSetting"><code>&amp;LoadSetting</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>設定ファイルを再読み込みします。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_MayuDialog"><code>&amp;MayuDialog(<em>dialog</em>, <em>show_command</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>「窓使いの憂鬱」のダイアログボックスを表示したり隠したりします。<code><em>dialog</em></code> には <code>Investigate</code> と <code>Log</code> が指定できます。それぞれ「調査」ダイアログと「ログ」ダイアログです。<code><em>show_command</em></code> には、<code>HIDE</code>, <code>SHOW</code>, <code>SHOWNA</code> などが指定できます。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_MouseMove"><code>&amp;MouseMove(<em>dx</em>, <em>dy</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>マウスカーソルを水平に <code><em>dx</em></code>、垂直に <code><em>dy</em></code> 移動します。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_MouseWheel"><code>&amp;MouseWheel(<em>delta</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>ホイールを回します。<code><em>delta</em></code> を <code>-120</code> にするとホイールを手前に 1 単位まわしたことになります。逆に <code>120</code> にするとホイールを奥へ 1 単位まわしたことになります。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_OtherWindowClass"><code>&amp;OtherWindowClass</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p><a href="#matchManyClasses"><code>window</code> に複数該当する場合</a>参照。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_PostMessage"><code>&amp;PostMessage(<em>window</em>, <em>message</em>, <em>wParam</em>, <em>lParam</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>ウィンドウへメッセージを送ることができます。高度な機能なので完全に理解してから利用してください。</p>
		  
		  <p class="sample">
		  keyseq $WM_CUT = &amp;PostMessage(ToItself, 0x0300, 0, 0)<br>
		  window EditControl /:Edit$/ : Global<br>
		  key C-W =&gt; $WM_CUT
		  </p>

		  <p class="continue">と書くと、一部のウィンドウで <kbd>[Control]</kbd> + <kbd>[W]</kbd> でカットできるようになります。</p>
		  
		  <p><code><em>window</em></code> には、メッセージを送る先のウィンドウを指定します。以下の種類があります。</p>

		  <ul>
		    <li><code>ToItself</code> はそのウィンドウ自身へ。
		    <li><code>ToMainWindow</code> は最も親のウィンドウへ。
		    <li><code>ToOverlappedWindow</code> は子でない最初のウィンドウへ。
		    <li><code>ToParentWindow</code> は親ウィンドウへ。
		    <li><code><em>正の数</em></code> は <code>1</code>:親ウィンドウ、<code>2</code>:親の親、<code>3</code>:親の親の親…
		  </ul>
		  
		  <p>どのようなメッセージを送ればよいかは Spy++ などで調べられますが、<code>WM_COMMAND</code> と <code>WM_SYSCOMMAND</code> については <a href="#function_InvestigateCommand"><code>&amp;InvestigateCommand</code></a> で調べることもできます。</p>
		  </div>

	      <dt class="h3"><a name="function_Repeat"><code>&amp;Repeat(<em>キーシーケンス</em>, <em>最大回数</em>)</code></a>

	      <dd class="d3">
		  <div>
		  <p><a href="#function_Variable"><code>&amp;Variable</code></a> で設定した回数だけ <code><em>キーシーケンス</em></code> を実行します。ただし、実行しすぎると危険なので<em>最大回数</em>を指定できます。<em>最大回数</em>は省略することができ、その場合 10 回が最大になります。</p>

		  <p class="sample">
		  key A =&gt; &amp;Variable(0, 10) &amp;Repeat((X))
		  </p>

		  <p>上の例では、<kbd>[A]</kbd> を押すと、<kbd>[X]</kbd> が 10 回入力されます</p>
		  
		  </div>
		  
	      <dt class="h3"><a name="function_Prefix"><code>&amp;Prefix(<em>キーマップ名</em>, <em>ignore_modifiers</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>プレフィックスキーを指定します。例えば、</p>
		  
		  <p class="sample">
		  keymap2 NotepadC-X<br>
		  mod !shift !alt !control !windows<br>
		  key	C-C =&gt; &amp;WindowClose<br>
		  window Notepad /:Notepad:Edit$/ : Global<br>
		  key	C-X =&gt; &amp;Prefix(NotepadC-X)
		  </p>
		  
		  <p class="continue">というように記述しておくと、メモ帳で <kbd>[Control]</kbd> + <kbd>[X]</kbd> <kbd>[Control]</kbd> + <kbd>[C]</kbd> と続けて入力するとメモ帳を終了することができます。</p>
		  
		  <p><code><em>ignore_modifiers</em></code> は省略可能な引数で <code>true</code> か <code>false</code> を指定します。省略すると <code>true</code> が指定されたとみなされます。<code>true</code> が指定された場合、<code><em>キーマップ名</em></code> で指示されるキーマップは</p>
		  
		  <p class="sample">
		  mod !shift !alt !control !windows
		  </p>
		  
		  <p class="continue">が指定されたものとして扱われます。</p>
		  
		  <p><a href="#keymap2"><code>keymap2</code></a> を利用しているときには、デフォルトキーが <a href="#function_Undefined"><code>&amp;Undefined</code></a> になっているので、モディファイヤを入力した時にもベルが鳴るはずですが、このように <code>true</code> を指定しておけば鳴らなくなります。(<a href="#mod"><code>mod</code></a> を参照)</p>
		  </div>

	      <dt class="h3"><a name="function_ShellExecute"><code>&amp;ShellExecute(<em>operation</em>, <em>file</em>, <em>parameters</em>, <em>directory</em>, <em>show_command</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>プログラムを実行します。</p>
		  
		  <ul>
		    <li><code><em>operation</em></code> ではファイルに対してどのような操作をするかを指示し、通常 <code>open</code> を指定します。
		    <li><code><em>file</em></code> にはファイルか実行ファイルを書きます。
		    <li><code><em>parameters</em></code> には <code><em>file</em></code> に実行ファイルを書いたときにオプションを記述します。
		    <li><code><em>directory</em></code> は作業ディレクトリを指定します。
		    <li><code><em>show_command</em></code> には <code>ShowNormal</code> を指定します。
		  </ul>
		  
		  <p>コントロールパネルを開く例:</p>
		  
		  <p class="sample">
		  key M-B =&gt; &amp;ShellExecute("open", "C:\\winnt\\system32\\Control.exe",,, ShowNormal)
		  </p>
		  
		  <p>システムのプロパティを開く例:</p>
		  
		  <p class="sample">
		  key M-C =&gt; &amp;ShellExecute("open", "C:/winnt/system32/Control.exe", "sysdm.cpl",, ShowNormal)
		  </p>
		  
		  <p>インターネットエクスプローラで「窓使いの憂鬱」のホームページを開く例:</p>
		  
		  <p class="sample">
		  key M-I =&gt; &amp;ShellExecute("open", "C:\\Program Files\\Plus!\\Microsoft Internet\\IEXPLORE.EXE\", "http://mayu.sourceforge.net",, ShowNormal)<br>
		  key M-H =&gt; &amp;ShellExecute("open", "http://mayu.sourceforge.net",,, ShowNormal)
		  </p>
		  
		  <p><code>canyon.mid</code> を演奏する例:</p>
		  
		  <p class="sample">
		  key M-R =&gt; &amp;ShellExecute("play", "C:\\winnt\\Media\\canyon.mid",,, ShowNormal)
		  </p>
		  </div>

	      <dt class="h3"><a name="function_Sync"><code>&amp;Sync</code></a>
	      <dd class="d3">
		  <div>
		  <p>基本的に、Windows へのキー入力と <code><em>FUNCTION</em></code> は非同期に実行されます。つまりキー入力と <code><em>FUNCTION</em></code> の実行順序は不明です。例えば、</p>

		  <p class="sample">
		  key C-A =&gt; A &amp;WindowMinimize
		  </p>

		  <p class="continue">このように記述して <kbd>[Control]</kbd> + <kbd>[A]</kbd> を入力すると、Windows へ <code>A</code> が入力されるのが先か、<code>&amp;WindowMinimize</code> が実行されるのが先かは不明です。そこで、以下のように記述すればちゃんと順序が守られることを保証できます。</p>
		  
		  <p class="sample">
		  key C-A =&gt; A &amp;Sync &amp;WindowMinimize
		  </p>

		  <p>また、<code><em>FUNCTION</em></code> には<a href="#modifier">モディファイヤ</a>を指定することが可能ですが、<code><em>FUNCTION</em></code> とモディファイヤキー入力が非同期に実行されるため通常は意味がありません。しかし、<code>&amp;Sync</code> を使えばモディファイヤキーの指定に意味が出てきます。</p>

		  <p class="sample">
		  window Explorer /Explorer\.exe/ : Global<br>
		  key C-S-Z =&gt; &amp;Sync &amp;WindowMaximize # ウィンドウの最大化<br>
		  key C-A-Z =&gt; C-&amp;Sync *&amp;WindowMaximize # ウィンドウの全画面化
		  </p>

		  <p>前者の指定では、ウィンドウを最大化するときに <kbd>[Control]</kbd> と <kbd>[Shift]</kbd> が入力されていないようにしています。後者では、<kbd>[Control]</kbd> は入力されるが、<kbd>[Alt]</kbd> は入力されていないようにします。</p>
		  
		  <p><a href="#def_sync"><code>def sync</code></a> 参照。</p>
		  </div>

	      <dt class="h3"><a name="function_Toggle"><code>&amp;Toggle(Lock<em>N</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>ロックキーをトグルします。<code>&amp;Toggle(Lock0)</code>〜<code>&amp;Toggle(Lock9)</code> が利用できます。</p>
		  </div>

	      <dt class="h3"><a name="function_Undefined"><code>&amp;Undefined</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>キーに何も割り当てられていないことにします。もしそのキーが押されると、ベルが鳴ります。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_VK"><code>&amp;VK(<em>virtual_key</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>仮想キーを Windows へ入力します。仮想キーには、物理的なキーボードから入力できないキーも存在しますのでそのようなキーの入力に使用します。仮想キーを調べるには、<a href="MANUAL.html#KEYNAME">key investigation</a> を参照してください。例えば、</p>
		  
		  <p class="sample">
		  key 変換 =&gt; &amp;VK(F13)
		  </p>
		  
		  <p class="continue">と記述すると <kbd>[変換]</kbd> キーを押すと <kbd>[F13]</kbd> を入力できます。又、<code>E-</code> を付けると拡張キーを表し、<code>D-</code> はキーを押す、<code>U-</code> はキーを離すことを表します。</p>
		  
		  <p><code><em>virtual_key</em></code> に <code>LButton</code>、<code>MButton</code>、<code>RButton</code> を指定することによって、マウスのボタンをシミュレートすることができます。</p>
		  
		  <p>この <code><em>FUNCTION</em></code> を利用するときは、必ず最後にキーを離していることを確認してください (つまり最後に <code>&amp;VK(U-F13)</code> などを書いておく)。さもないと、そのキーが押されっぱなしになります。</p>
		  </div>

	      <dt class="h3"><a name="function_Variable"><code>&amp;Variable(<em>mag</em>, <em>inc</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>内部変数を <code><em>mag</em></code> 倍してから <code><em>inc</em></code> を加えます。この変数は、<a href="CUSTOMIZE.html#function_Repeat"><code>&amp;Repeat</code></a> と <a href="CUSTOMIZE.html#function_HelpVariable"><code>&amp;HelpVariable</code></a> で使用されます。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_Wait"><code>&amp;Wait(<em>milli_second</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p><code><em>milli_second</em></code> ミリ秒だけ実行を中断します。その間はキーを入力することはできません。最大 5 秒待つことができます。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_WindowCling"><code>&amp;WindowClingToLeft</code>, <code>&amp;WindowClingToRight</code>, <code>&amp;WindowClingToTop</code>, <code>&amp;WindowClingToBottom</code>, </a>
		  
	      <dd class="d3">
		  <div>
		  <p>ウィンドウを、それぞれの辺が画面のそれぞれの辺にくっつくように移動させます。引数に <code>MDI</code> を指定すると、MDI 子ウィンドウを操作します。</p>
		  
		  <ul>
		    <li><code>&amp;WindowClingToTop</code> は <a href="#function_WindowMoveTo"><code>&amp;WindowMoveTo(N, 0, 0)</code></a>と同じ。
		    <li><code>&amp;WindowClingToRight</code> は <a href="#function_WindowMoveTo"><code>&amp;WindowMoveTo(E, 0, 0)</code></a> と同じ。
		    <li><code>&amp;WindowClingToLeft</code> は <a href="#function_WindowMoveTo"><code>&amp;WindowMoveTo(W, 0, 0)</code></a> と同じ。
		    <li><code>&amp;WindowClingToBottom</code> は <a href="#function_WindowMoveTo"><code>&amp;WindowMoveTo(S, 0, 0)</code></a> と同じ。
		  </ul>
		  </div>
		  
	      <dt class="h3"><a name="function_WindowClose"><code>&amp;WindowClose</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>ウィンドウを閉じます。引数に <code>MDI</code> を指定すると、MDI 子ウィンドウを操作します。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_WindowIdentify"><code>&amp;WindowIdentify</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>ウィンドウのウィンドウクラス名とタイトルを調べログに出力します。又、各種ウィンドウの位置と大きさも出力します。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_WindowMaxMinHVMax"><code>&amp;WindowMinimize</code>, <code>&amp;WindowMaximize</code>, <code>&amp;WindowHMaximize</code>, <code>&amp;WindowVMaximize</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>それぞれ、ウィンドウを最小化、最大化、横方向に最大化、縦方向に最大化します。引数に <code>MDI</code> を指定すると、MDI 子ウィンドウを操作します。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_WindowMove"><code>&amp;WindowMove(<em>dx</em>, <em>dy</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>ウインドウを水平方向に <code><em>dx</em></code>、垂直方向に <code><em>dy</em></code> 移動します。<code>MDI</code> を引数の最後に追加指定すると、MDI 子ウィンドウを操作します。<code>&amp;WindowMoveTo(C, <em>dx</em>, <em>dy</em>)</code> と同じ動作をします。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_WindowMoveTo"><code>&amp;WindowMoveTo(<em>gravity</em>, <em>dx</em>, <em>dy</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>基準位置から相対的にウインドウを水平方向に <code><em>dx</em></code>、垂直方向に <code><em>dy</em></code> 移動します。<code>MDI</code> を引数の最後に追加指定すると、MDI 子ウィンドウを操作します。<code><em>gravity</em></code> には、次のものが指定できます。</p>

		  <ul>
		    <li><code>C</code> : 現在位置からの相対位置に移動します。
		    <li><code>N</code> : 上下方向はデスクトップの上からの相対位置、左右方向は現在位置からの相対位置に移動します。
		    <li><code>E</code> : 上下方向は現在位置からの相対位置、左右方向はデスクトップの右からの相対位置に移動します。
		    <li><code>W</code> : 上下方向は現在位置からの相対位置、左右方向はデスクトップの左からの相対位置に移動します。
		    <li><code>S</code> : 上下方向はデスクトップの下からの相対位置、左右方向は現在位置からの相対位置に移動します。
		    <li><code>NE</code> : デスクトップ右上からの相対位置に移動。
		    <li><code>NW</code> : デスクトップ左上からの相対位置に移動。
		    <li><code>SE</code> : デスクトップ右下からの相対位置に移動。
		    <li><code>SW</code> : デスクトップ左下からの相対位置に移動。
		  </ul>
		  
		  <p>また、他の移動 <code><em>FUNCTION</em></code> とは以下のような関係があります。</p>
		  
		  <ul>
		    <li><code>&amp;WindowMoveTo(C, <em>dx</em>, <em>dy</em>)</code> は <a href="#function_WindowMove"><code>&amp;WindowMove(<em>dx</em>, <em>dy</em>)</code></a> と同じ。
		    <li><code>&amp;WindowMoveTo(N, 0, 0)</code> は <a href="#function_WindowCling"><code>&amp;WindowClingToTop</code></a> と同じ。
		    <li><code>&amp;WindowMoveTo(E, 0, 0)</code> は <a href="#function_WindowCling"><code>&amp;WindowClingToRight</code></a> と同じ。
		    <li><code>&amp;WindowMoveTo(W, 0, 0)</code> は <a href="#function_WindowCling"><code>&amp;WindowClingToLeft</code></a> と同じ。
		    <li><code>&amp;WindowMoveTo(S, 0, 0)</code> は <a href="#function_WindowCling"><code>&amp;WindowClingToBottom</code></a> と同じ。
		  </ul>
		  </div>
		  
	      <dt class="h3"><a name="function_WindowMoveVisibly"><code>&amp;WindowMoveVisibly</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>ウィンドウ全体が画面に表示されるような位置へウィンドウを移動します。引数に <code>MDI</code> を指定すると、MDI 子ウィンドウを操作します。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_WindowRedraw"><code>&amp;WindowRedraw</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>ウィンドウを強制的に再描画させます。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_WindowResizeTo"><code>&amp;WindowResizeTo(<em>width</em>, <em>height</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>ウインドウの大きさを幅 <code><em>width</em></code>、高さ <code><em>height</em></code> に変更します。<code>0</code> を指定すると現在の大きさに、負の値を指定するとデスクトップの大きさより指定したピクセル数だけ小さい大きさになります。<code>MDI</code> を引数の最後に追加指定すると、MDI 子ウィンドウを操作します。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_WindowRiseLower"><code>&amp;WindowRaise</code>, <code>&amp;WindowLower</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>それぞれ、ウィンドウを一番上、一番下へ移動します。引数に <code>MDI</code> を指定すると、MDI 子ウィンドウを操作します。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_WindowSetAlpha"><code>&amp;WindowSetAlpha(<em>alpha</em>)</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>ウィンドウを半透明化、又は半透明化解除します。トグルになっています。<code><em>alpha</em></code> は半透明の度合いを表し、<code>0</code> で透明、<code>100</code> で不透明になります。<code>-1</code> を指定すると、この <code><em>FUNCTION</em></code> で半透明化されたウィンドウを全て不透明状態に戻します。</p>
		  </div>
		  
	      <dt class="h3"><a name="function_WindowToggleTopMost"><code>&amp;WindowToggleTopMost</code></a>
		  
	      <dd class="d3">
		  <div>
		  <p>ウィンドウの最前面フラグをトグルします。</p>
		  </div>
	    </dl>
	    </div>
	    
	<dt class="h2"><a name="compile">x. ビルド</a>

	<dd class="d2">
	    <div>
	    <p>まず、<code>source.cab</code> を「窓使いの憂鬱」をインストールしたディレクトリでディレクトリ付きで展開します。</p>
	    
	    <p>Visual C++ 6.0 を使う場合は、コマンドプロンプトで</p>
	    
	    <p class="sample">
	    C:\mayu&gt; nmake -f mayu-vc.mak nodebug=1
	    </p>
	    
	    <p class="continue">とします。Visual C++ 6.0 のコンパイラなどにパスが通っている必要があります。Windows2000 DDK をダウンロードしてくれば、<code>d</code> ディレクトリ以下にあるドライバをビルドすることができます (その方法は書きませんので適当にやってください)。</p>
	    
	    <p>Borland C++ 5.5 を使う場合は、コマンドプロンプトで</p>
	    
	    <p class="sample">
	    C:\mayu&gt; make -f mayu-bcc.mak nodebug=1
	    </p>
	    
	    <p class="continue">とします。Borland C++ 5.5 のコンパイラなどにパスが通っている必要があります。また、<code>bcc.mak</code> の冒頭の注意に従ってライブラリパスに <code>lib/psdk</code> を含めてください。ドライバをビルドする方法は不明です。</p>
	    
	    <p>どちらのコンパイラを使う場合でも、<code>nodebug=1</code> を削除すれば、デバッグ情報を生成します。何かパッチを作ったらぜひ作者までお知らせください。</p>
	    </div>
      </dl>
      </div>
</dl>

</div>

</body>
</html>
